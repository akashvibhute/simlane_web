{% extends "base.html" %}

{% load static %}

{% block title %}
  FOV Calculator - SimLane
{% endblock title %}
{% block css %}
  {{ block.super }}
{% endblock css %}
{% block content %}
  <div class="max-w-7xl mx-auto py-8">
    <div class="text-center mb-8">
      <h1 class="text-4xl font-bold text-gray-900 mb-4">FOV Calculator</h1>
      <p class="text-lg text-gray-600">Calculate your optimal Field of View for sim racing setups</p>
    </div>
    <!-- Configuration Panel - Horizontal Layout -->
    <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-200 mb-6">
      <h2 class="text-xl font-bold text-gray-900 mb-4">Configuration</h2>
      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
        <!-- Monitor Setup -->
        <div>
          <label class="block font-semibold text-gray-700 mb-2 text-sm">Monitor Setup</label>
          <div class="flex gap-1">
            <button class="px-2 py-1 border rounded-md cursor-pointer transition-all text-xs font-medium toggle-btn active bg-blue-600 text-white border-blue-600"
                    data-setup="single">Single</button>
            <button class="px-2 py-1 border rounded-md cursor-pointer transition-all hover:bg-gray-50 text-xs font-medium toggle-btn bg-white border-gray-300"
                    data-setup="triple">Triple</button>
          </div>
        </div>
        <!-- Monitor Type -->
        <div>
          <label class="block font-semibold text-gray-700 mb-2 text-sm">Monitor Type</label>
          <div class="flex gap-1">
            <button class="px-2 py-1 border rounded-md cursor-pointer transition-all text-xs font-medium toggle-btn active bg-blue-600 text-white border-blue-600"
                    data-type="flat">Flat</button>
            <button class="px-2 py-1 border rounded-md cursor-pointer transition-all hover:bg-gray-50 text-xs font-medium toggle-btn bg-white border-gray-300"
                    data-type="curved">Curved</button>
          </div>
        </div>
        <!-- Monitor Size -->
        <div>
          <label for="monitor-size"
                 class="block font-semibold text-gray-700 mb-2 text-sm">Monitor Size (inches)</label>
          <select id="monitor-size"
                  class="w-full px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200">
            <option value="21.5">21.5"</option>
            <option value="24">24"</option>
            <option value="27">27"</option>
            <option value="28">28"</option>
            <option value="32" selected>32"</option>
            <option value="34">34" (UW)</option>
            <option value="35">35" (UW)</option>
            <option value="38">38" (UW)</option>
            <option value="43">43"</option>
            <option value="49">49" (SUW)</option>
            <option value="custom">Custom...</option>
          </select>
          <input type="number"
                 id="monitor-size-custom"
                 class="w-full px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200 mt-1 hidden"
                 placeholder="Enter size"
                 min="10"
                 max="100"
                 step="0.1" />
        </div>
        <!-- Aspect Ratio -->
        <div>
          <label for="aspect-ratio"
                 class="block font-semibold text-gray-700 mb-2 text-sm">Aspect Ratio</label>
          <select id="aspect-ratio"
                  class="w-full px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200">
            <option value="4:3">4:3</option>
            <option value="5:4">5:4</option>
            <option value="16:10">16:10</option>
            <option value="16:9" selected>16:9</option>
            <option value="21:9">21:9 (UW)</option>
            <option value="24:10">24:10 (UW)</option>
            <option value="32:9">32:9 (SUW)</option>
          </select>
        </div>
        <!-- Distance to Screen -->
        <div>
          <label for="distance" class="block font-semibold text-gray-700 mb-2 text-sm">Distance</label>
          <div class="flex gap-1">
            <input type="number"
                   id="distance"
                   class="flex-1 px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200"
                   value="62"
                   min="10"
                   max="500"
                   step="1" />
            <select id="distance-unit"
                    class="px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200">
              <option value="cm">cm</option>
              <option value="mm">mm</option>
              <option value="in">in</option>
            </select>
          </div>
        </div>
        <!-- Resolution (Optional) -->
        <div>
          <label for="resolution"
                 class="block font-semibold text-gray-700 mb-2 text-sm">
            Resolution <span class="text-xs text-gray-400">(ref)</span>
          </label>
          <select id="resolution"
                  class="w-full px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200">
            <option value="1920x1080">1920x1080</option>
            <option value="2560x1440" selected>2560x1440</option>
            <option value="3840x2160">3840x2160</option>
            <option value="3440x1440">3440x1440</option>
            <option value="5120x1440">5120x1440</option>
          </select>
        </div>
      </div>
      <!-- Additional Controls Row (shown when needed) -->
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
        <!-- Curved Monitor Radius -->
        <div class="hidden" id="curve-radius-group">
          <label for="curve-radius"
                 class="block font-semibold text-gray-700 mb-2 text-sm">Curve Radius (R)</label>
          <select id="curve-radius"
                  class="w-full px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200">
            <option value="1800">1800R</option>
            <option value="1500">1500R</option>
            <option value="1000" selected>1000R</option>
            <option value="800">800R</option>
          </select>
        </div>
        <!-- Monitor Angle -->
        <div class="hidden" id="monitor-angle-group">
          <label for="monitor-angle"
                 class="block font-semibold text-gray-700 mb-2 text-sm">Angle Between Monitor Planes (degrees)</label>
          <input type="number"
                 id="monitor-angle"
                 class="w-full px-2 py-1 border border-gray-300 rounded-md text-xs transition-all focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200"
                 value="60"
                 min="0"
                 max="90"
                 step="5" />
        </div>
        <!-- Projection Mode -->
        <div class="hidden" id="projection-mode-group">
          <label class="block font-semibold text-gray-700 mb-2 text-sm">Projection Mode</label>
          <div class="flex space-x-1">
            <button type="button"
                    data-projection="single"
                    class="projection-btn px-2 py-1 text-xs border rounded-md bg-white border-gray-300">
              Single
            </button>
            <button type="button"
                    data-projection="multi"
                    class="projection-btn px-2 py-1 text-xs border rounded-md bg-blue-600 text-white border-blue-600 active">
              Multi
            </button>
          </div>
          <div class="text-xs text-gray-500 mt-1">
            <strong>Single:</strong> One wide view
            <br />
            <strong>Multi:</strong> Each monitor separate
          </div>
        </div>
      </div>
    </div>
    <!-- Combined Visualization and Results -->
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
      <!-- Visualization Panel -->
      <div class="lg:col-span-3 bg-white rounded-xl p-6 shadow-sm border border-gray-200">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold text-gray-900">
            Setup Visualization
            <span class="text-sm font-normal text-gray-600">(Top View)</span>
          </h2>
          <!-- FOV Results - Inline -->
          <div class="flex space-x-4 text-sm">
            <div class="text-center">
              <div class="text-lg font-bold text-blue-700" id="horizontal-fov">84°</div>
              <div class="text-gray-600 text-xs">H-FOV</div>
            </div>
            <div class="text-center">
              <div class="text-lg font-bold text-blue-700" id="vertical-fov">53°</div>
              <div class="text-gray-600 text-xs">V-FOV</div>
            </div>
            <div class="text-center hidden" id="total-fov-display">
              <div class="text-lg font-bold text-blue-700" id="total-fov">126°</div>
              <div class="text-gray-600 text-xs" id="total-fov-label">Game FOV</div>
            </div>
          </div>
        </div>
        <div class="relative w-full h-96 border border-gray-200 rounded-lg bg-gray-50 overflow-hidden">
          <canvas id="visualization-canvas" class="w-full h-full"></canvas>
        </div>
        <div class="flex justify-center mt-3 space-x-4 text-xs text-gray-600">
          <div class="flex items-center">
            <div class="w-3 h-3 bg-blue-500 mr-1 rounded"></div>
            <span>Monitor(s)</span>
          </div>
          <div class="flex items-center">
            <div class="w-3 h-3 bg-green-500 mr-1 rounded"></div>
            <span>Driver</span>
          </div>
          <div class="flex items-center">
            <div class="w-3 h-3 bg-red-300 mr-1 rounded opacity-50"></div>
            <span>FOV</span>
          </div>
        </div>
      </div>
      <!-- Setup Information Panel -->
      <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-200">
        <h2 class="text-xl font-bold text-gray-900 mb-4">Setup Info</h2>
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
          <h4 class="text-blue-700 font-semibold mb-2 text-sm">Monitor Setup</h4>
          <div id="setup-info" class="text-xs text-gray-700 space-y-1">
            <p>
              <strong>Monitor:</strong> <span id="info-monitor">32" Single Flat Monitor</span>
            </p>
            <p>
              <strong>Distance:</strong> <span id="info-distance">62 cm</span>
            </p>
            <p>
              <strong>Screen Width:</strong> <span id="info-width">70.8 cm</span>
            </p>
          </div>
        </div>
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
          <h4 class="text-blue-700 font-semibold mb-2 text-sm">How to Use</h4>
          <p class="text-xs text-gray-600 mb-3">
            Use the calculated horizontal FOV value in your sim racing game settings.
            The FOV represents the angle of vision that matches your real-world viewing angle.
          </p>
          <p class="text-xs text-gray-500 italic">
            💡 FOV depends only on physical screen size, aspect ratio, and distance - not resolution.
          </p>
        </div>
      </div>
    </div>
  </div>
{% endblock content %}
{% block inline_javascript %}
  {{ block.super }}
  <script>
    class FOVCalculator {
      constructor() {
        this.canvas = document.getElementById('visualization-canvas');
        if (!this.canvas) {
          console.error('Canvas element not found!');
          return;
        }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) {
          console.error('Canvas context not available!');
          return;
        }
        console.log('FOV Calculator initialized');
        this.setupEventListeners();
        this.toggleMultiMonitorControls(); // Initialize controls visibility
        this.toggleCurveControls(); // Initialize curve controls visibility
        this.resizeCanvas();
        this.updateCalculation();
        window.addEventListener('resize', () => this.resizeCanvas());
      }

      setupEventListeners() {
        // Setup type toggles
        document.querySelectorAll('[data-setup]').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('[data-setup]').forEach(b => {
              b.classList.remove('active', 'bg-blue-600', 'text-white', 'border-blue-600');
              b.classList.add('bg-white', 'border-gray-300');
            });
            btn.classList.add('active', 'bg-blue-600', 'text-white', 'border-blue-600');
            btn.classList.remove('bg-white', 'border-gray-300');
            this.toggleMultiMonitorControls();
            this.updateCalculation();
          });
        });

        // Monitor type toggles
        document.querySelectorAll('[data-type]').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('[data-type]').forEach(b => {
              b.classList.remove('active', 'bg-blue-600', 'text-white', 'border-blue-600');
              b.classList.add('bg-white', 'border-gray-300');
            });
            btn.classList.add('active', 'bg-blue-600', 'text-white', 'border-blue-600');
            btn.classList.remove('bg-white', 'border-gray-300');
            this.toggleCurveControls();
            this.updateCalculation();
          });
        });

        // Projection mode toggles
        document.querySelectorAll('[data-projection]').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('[data-projection]').forEach(b => {
              b.classList.remove('active', 'bg-blue-600', 'text-white', 'border-blue-600');
              b.classList.add('bg-white', 'border-gray-300');
            });
            btn.classList.add('active', 'bg-blue-600', 'text-white', 'border-blue-600');
            btn.classList.remove('bg-white', 'border-gray-300');
            this.updateCalculation();
          });
        });

        // Monitor size change handler
        document.getElementById('monitor-size').addEventListener('change', () => {
          this.toggleCustomSizeInput();
          this.updateCalculation();
        });

        // Input changes
        ['distance', 'curve-radius', 'monitor-angle', 'monitor-size-custom'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('input', () => this.updateCalculation());
          }
        });

        // Select changes
        ['resolution', 'aspect-ratio', 'distance-unit'].forEach(id => {
          document.getElementById(id).addEventListener('change', () => this.updateCalculation());
        });
      }

      toggleMultiMonitorControls() {
        const setup = document.querySelector('[data-setup].active').dataset.setup;
        const angleGroup = document.getElementById('monitor-angle-group');
        const projectionGroup = document.getElementById('projection-mode-group');
        const totalFovDisplay = document.getElementById('total-fov-display');

        if (setup === 'triple') {
          angleGroup.classList.remove('hidden');
          projectionGroup.classList.remove('hidden');
          totalFovDisplay.classList.remove('hidden');
        } else {
          angleGroup.classList.add('hidden');
          projectionGroup.classList.add('hidden');
          totalFovDisplay.classList.add('hidden');
        }
      }

      toggleCurveControls() {
        const type = document.querySelector('[data-type].active').dataset.type;
        const curveGroup = document.getElementById('curve-radius-group');
        if (type === 'curved') {
          curveGroup.classList.remove('hidden');
        } else {
          curveGroup.classList.add('hidden');
        }
      }

      toggleCustomSizeInput() {
        const sizeSelect = document.getElementById('monitor-size');
        const customInput = document.getElementById('monitor-size-custom');

        if (sizeSelect.value === 'custom') {
          customInput.classList.remove('hidden');
          customInput.focus();
        } else {
          customInput.classList.add('hidden');
        }
      }

      updateCalculation() {
        const setup = document.querySelector('[data-setup].active').dataset.setup;
        const type = document.querySelector('[data-type].active').dataset.type;
        const sizeSelect = document.getElementById('monitor-size');
        const customSizeInput = document.getElementById('monitor-size-custom');
        const size = sizeSelect.value === 'custom' ?
          parseFloat(customSizeInput.value) || 32 :
          parseFloat(sizeSelect.value);

        // Handle distance unit conversion
        const distanceValue = parseFloat(document.getElementById('distance').value);
        const distanceUnit = document.getElementById('distance-unit').value;
        let distance; // Always convert to cm for calculations
        switch (distanceUnit) {
          case 'mm':
            distance = distanceValue / 10;
            break;
          case 'in':
            distance = distanceValue * 2.54;
            break;
          default: // cm
            distance = distanceValue;
            break;
        }

        const resolution = document.getElementById('resolution').value;
        const aspectRatio = document.getElementById('aspect-ratio').value;
        const curveRadius = type === 'curved' ? parseInt(document.getElementById('curve-radius').value) : null;
        const monitorAngle = (setup === 'triple') ? parseFloat(document.getElementById('monitor-angle').value) : 0;
        const projectionMode = (setup === 'triple') ? document.querySelector('[data-projection].active')?.dataset.projection || 'multi' : 'single';

        // Calculate physical dimensions
        const [aspectW, aspectH] = aspectRatio.split(':').map(x => parseFloat(x));
        const diagonal = size * 2.54; // Convert inches to cm
        const screenWidth = diagonal * aspectW / Math.sqrt(aspectW * aspectW + aspectH * aspectH);
        const screenHeight = diagonal * aspectH / Math.sqrt(aspectW * aspectW + aspectH * aspectH);

        // Calculate FOV
        let horizontalFOV, verticalFOV, totalFOV;

        if (type === 'curved' && curveRadius) {
          // For curved monitors, adjust the calculation
          const effectiveWidth = screenWidth * (curveRadius / (curveRadius + distance));
          horizontalFOV = 2 * Math.atan(effectiveWidth / (2 * distance)) * (180 / Math.PI);
        } else {
          horizontalFOV = 2 * Math.atan(screenWidth / (2 * distance)) * (180 / Math.PI);
        }

        verticalFOV = 2 * Math.atan(screenHeight / (2 * distance)) * (180 / Math.PI);

        // Calculate total FOV for multi-monitor setups
        if (setup === 'triple') {
          if (projectionMode === 'multi') {
            // Multi-projection triple screen calculation
            // In multi-projection mode, each monitor renders its own view independently
            // The FOV should be the same as a single monitor since each screen gets its own projection
            // This is the standard approach used in sim racing for triple screen setups
            totalFOV = horizontalFOV;

          } else {
            // Single projection calculation - treat as one continuous wide screen
            const sideAngleRad = ((180 - monitorAngle) / 2) * Math.PI / 180;

            // Distance from center to outer edge of side monitors
            const sideMonitorOffset = screenWidth * Math.sin(sideAngleRad);
            const totalHorizontalSpan = screenWidth + 2 * sideMonitorOffset;

            totalFOV = 2 * Math.atan(totalHorizontalSpan / (2 * distance)) * (180 / Math.PI);
          }
        }

        // Update display
        document.getElementById('horizontal-fov').textContent = Math.round(horizontalFOV) + '°';
        document.getElementById('vertical-fov').textContent = Math.round(verticalFOV) + '°';

        if (totalFOV) {
          document.getElementById('total-fov').textContent = Math.round(totalFOV) + '°';

          // Update the label based on projection mode
          const totalFovLabel = document.getElementById('total-fov-label');
          if (projectionMode === 'multi') {
            totalFovLabel.textContent = 'Game FOV';
          } else {
            totalFovLabel.textContent = 'Total FOV';
          }
        }

        // Update info
        const monitorCount = setup === 'single' ? 'Single' : 'Triple';
        const monitorType = type === 'flat' ? 'Flat' : `Curved (${curveRadius}R)`;
        document.getElementById('info-monitor').textContent = `${size}" ${monitorCount} ${monitorType} Monitor${setup === 'single' ? '' : 's'}`;
        document.getElementById('info-distance').textContent = `${distanceValue} ${distanceUnit}`;
        document.getElementById('info-width').textContent = `${screenWidth.toFixed(1)} cm`;

        // Debug logging for triple setup
        if (setup === 'triple') {
          console.log(`Debug - Triple Monitor Setup:`);
          console.log(`Screen width: ${screenWidth.toFixed(1)}cm, Angle between planes: ${monitorAngle}°`);
          console.log(`Side angle from center: ${((180 - monitorAngle) / 2).toFixed(1)}°`);
          console.log(`Distance: ${distance}cm`);
          console.log(`Individual monitor FOV: ${horizontalFOV.toFixed(1)}°`);
          console.log(`Projection mode: ${projectionMode}`);

          const sideAngleRad = ((180 - monitorAngle) / 2) * Math.PI / 180;
          const sideMonitorOffset = screenWidth * Math.sin(sideAngleRad);

          if (projectionMode === 'multi') {
            console.log(`Multi-projection: Each monitor uses individual FOV: ${horizontalFOV.toFixed(1)}°`);
            console.log(`Multi-projection Game FOV: ${totalFOV.toFixed(1)}°`);
          } else {
            const totalHorizontalSpan = screenWidth + 2 * sideMonitorOffset;
            console.log(`Single projection: Total horizontal span: ${totalHorizontalSpan.toFixed(1)}cm`);
            console.log(`Single projection calculated FOV: ${totalFOV.toFixed(1)}°`);
          }
        }

        // Update visualization
        this.drawVisualization(setup, type, screenWidth, distance, monitorAngle, horizontalFOV, totalFOV || horizontalFOV);
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        this.ctx.scale(dpr, dpr);

        this.updateCalculation();
      }

      drawVisualization(setup, type, screenWidth, distance, angle, singleFOV, totalFOV) {
        console.log('Drawing visualization:', {
          setup,
          type,
          screenWidth,
          distance,
          angle,
          totalFOV
        });

        const curveRadius = type === 'curved' ? parseInt(document.getElementById('curve-radius').value) : null;
        const ctx = this.ctx;
        const canvas = this.canvas;
        const dpr = window.devicePixelRatio || 1;

        const canvasWidth = canvas.width / dpr;
        const canvasHeight = canvas.height / dpr;

        console.log('Canvas dimensions:', {
          canvasWidth,
          canvasHeight,
          dpr
        });

        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Test drawing to ensure canvas is working
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        const centerX = canvasWidth / 2;
        const centerY = canvasHeight * 0.8;

        // Calculate scaling
        let totalSpan = screenWidth;
        if (setup === 'triple') {
          const sideAngleRad = ((180 - angle) / 2) * Math.PI / 180;
          const sideMonitorOffset = screenWidth * Math.sin(sideAngleRad);
          totalSpan = screenWidth + 2 * sideMonitorOffset;
        }

        const scale = Math.min(canvasWidth * 0.8 / totalSpan, canvasHeight * 0.5 / distance);
        const distancePixels = distance * scale;
        const screenPixels = screenWidth * scale;

        // Draw FOV arc
        const fovRadians = totalFOV * Math.PI / 180;
        const arcRadius = distancePixels * 1.2;

        ctx.strokeStyle = '#ef4444';
        ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, arcRadius, -Math.PI / 2 - fovRadians / 2, -Math.PI / 2 + fovRadians / 2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw monitors as thick lines
        ctx.strokeStyle = '#1e40af';
        ctx.lineWidth = 6;

        const monitorWidth = screenPixels;
        const monitorY = centerY - distancePixels;

        if (setup === 'single') {
          // Single monitor as a thick line
          if (type === 'curved' && curveRadius) {
            this.drawCurvedMonitorLine(ctx, centerX, monitorY, monitorWidth, curveRadius, screenPixels);
          } else {
            ctx.beginPath();
            ctx.moveTo(centerX - monitorWidth / 2, monitorY);
            ctx.lineTo(centerX + monitorWidth / 2, monitorY);
            ctx.stroke();
          }

        } else if (setup === 'triple') {
          const sideAngleRad = ((180 - angle) / 2) * Math.PI / 180;

          // Center monitor as a thick line
          if (type === 'curved' && curveRadius) {
            this.drawCurvedMonitorLine(ctx, centerX, monitorY, monitorWidth, curveRadius, screenPixels);
          } else {
            ctx.beginPath();
            ctx.moveTo(centerX - monitorWidth / 2, monitorY);
            ctx.lineTo(centerX + monitorWidth / 2, monitorY);
            ctx.stroke();
          }

          // Left monitor - positioned so front edge touches front edge of center monitor
          const leftMonitorX = centerX - monitorWidth / 2;
          ctx.save();
          ctx.translate(leftMonitorX, monitorY);
          ctx.rotate(-sideAngleRad);
          if (type === 'curved' && curveRadius) {
            this.drawCurvedMonitorLine(ctx, 0, 0, monitorWidth, curveRadius, screenPixels);
          } else {
            ctx.beginPath();
            ctx.moveTo(-monitorWidth, 0);
            ctx.lineTo(0, 0);
            ctx.stroke();
          }
          ctx.restore();

          // Right monitor - positioned so front edge touches front edge of center monitor
          const rightMonitorX = centerX + monitorWidth / 2;
          ctx.save();
          ctx.translate(rightMonitorX, monitorY);
          ctx.rotate(sideAngleRad);
          if (type === 'curved' && curveRadius) {
            this.drawCurvedMonitorLine(ctx, 0, 0, monitorWidth, curveRadius, screenPixels);
          } else {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(monitorWidth, 0);
            ctx.stroke();
          }
          ctx.restore();

          // Draw angle indicators - positioned at the junction points
          ctx.strokeStyle = '#6b7280';
          ctx.lineWidth = 1;
          ctx.setLineDash([2, 2]);

          // Left angle arc - at the junction between left and center monitors
          ctx.beginPath();
          ctx.arc(leftMonitorX, monitorY, 25, -Math.PI / 2, -Math.PI / 2 - sideAngleRad, true);
          ctx.stroke();

          // Right angle arc - at the junction between center and right monitors
          ctx.beginPath();
          ctx.arc(rightMonitorX, monitorY, 25, -Math.PI / 2, -Math.PI / 2 + sideAngleRad);
          ctx.stroke();

          ctx.setLineDash([]);
          ctx.strokeStyle = '#1e40af'; // Reset monitor color
          ctx.lineWidth = 6; // Reset monitor line width
        }

        // Draw driver position
        const driverRadius = Math.max(4, screenPixels * 0.02);

        ctx.fillStyle = '#10b981';
        ctx.beginPath();
        ctx.arc(centerX, centerY, driverRadius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = '#065f46';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Driver shoulders
        ctx.beginPath();
        ctx.ellipse(centerX, centerY + driverRadius + 2, driverRadius * 1.2, driverRadius * 0.6, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        // Draw distance line
        ctx.strokeStyle = '#6b7280';
        ctx.setLineDash([2, 2]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX, centerY - distancePixels);
        ctx.stroke();

        // Draw measurement lines passing through the front face of monitors
        const measurementExtension = 30 * scale; // 30cm proportional extension

        if (setup === 'single') {
          // Single monitor measurement line - passes through the monitor front face
          ctx.beginPath();
          ctx.moveTo(centerX - monitorWidth / 2 - measurementExtension, monitorY);
          ctx.lineTo(centerX + monitorWidth / 2 + measurementExtension, monitorY);
          ctx.stroke();

          // Tick marks for monitor edges only
          ctx.setLineDash([]);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(centerX - monitorWidth / 2, monitorY - 5);
          ctx.lineTo(centerX - monitorWidth / 2, monitorY + 5);
          ctx.moveTo(centerX + monitorWidth / 2, monitorY - 5);
          ctx.lineTo(centerX + monitorWidth / 2, monitorY + 5);
          ctx.stroke();

        } else if (setup === 'triple') {
          const sideAngleRad = ((180 - angle) / 2) * Math.PI / 180;

          // Center monitor measurement line - passes through the monitor front face
          ctx.beginPath();
          ctx.moveTo(centerX - monitorWidth / 2 - measurementExtension, monitorY);
          ctx.lineTo(centerX + monitorWidth / 2 + measurementExtension, monitorY);
          ctx.stroke();

          // Center monitor tick marks
          ctx.setLineDash([]);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(centerX - monitorWidth / 2, monitorY - 5);
          ctx.lineTo(centerX - monitorWidth / 2, monitorY + 5);
          ctx.moveTo(centerX + monitorWidth / 2, monitorY - 5);
          ctx.lineTo(centerX + monitorWidth / 2, monitorY + 5);
          ctx.stroke();

          // Left monitor measurement line - passes through the monitor front face
          const leftMonitorX = centerX - monitorWidth / 2;
          ctx.setLineDash([2, 2]);
          ctx.save();
          ctx.translate(leftMonitorX, monitorY);
          ctx.rotate(-sideAngleRad);
          ctx.beginPath();
          ctx.moveTo(-monitorWidth - measurementExtension / 2, 0);
          ctx.lineTo(measurementExtension / 2, 0);
          ctx.stroke();

          // Left monitor tick marks
          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.moveTo(-monitorWidth, -5);
          ctx.lineTo(-monitorWidth, 5);
          ctx.moveTo(0, -5);
          ctx.lineTo(0, 5);
          ctx.stroke();
          ctx.restore();

          // Right monitor measurement line - passes through the monitor front face
          const rightMonitorX = centerX + monitorWidth / 2;
          ctx.setLineDash([2, 2]);
          ctx.save();
          ctx.translate(rightMonitorX, monitorY);
          ctx.rotate(sideAngleRad);
          ctx.beginPath();
          ctx.moveTo(-measurementExtension / 2, 0);
          ctx.lineTo(monitorWidth + measurementExtension / 2, 0);
          ctx.stroke();

          // Right monitor tick marks
          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.moveTo(0, -5);
          ctx.lineTo(0, 5);
          ctx.moveTo(monitorWidth, -5);
          ctx.lineTo(monitorWidth, 5);
          ctx.stroke();
          ctx.restore();
        }

        ctx.setLineDash([]);

        // Labels
        const fontSize = Math.max(10, Math.min(14, canvasWidth * 0.025));

        // Distance label
        ctx.fillStyle = '#374151';
        ctx.font = `${fontSize}px sans-serif`;
        ctx.textAlign = 'left';
        const distanceUnit = document.getElementById('distance-unit').value;
        const distanceValue = parseFloat(document.getElementById('distance').value);
        ctx.fillText(`${distanceValue}${distanceUnit}`, centerX + 10, centerY - distancePixels / 2);

        // FOV label
        ctx.font = `bold ${fontSize * 1.2}px sans-serif`;
        ctx.fillStyle = '#dc2626';
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(totalFOV)}° FOV`, centerX, 20);

        // Driver label
        ctx.font = `${fontSize * 0.8}px sans-serif`;
        ctx.fillStyle = '#10b981';
        ctx.fillText('Driver', centerX, centerY + driverRadius + 15);

        // Angle labels for triple setup
        if (setup === 'triple') {
          const sideAngle = (180 - angle) / 2;
          ctx.font = `${fontSize * 0.7}px sans-serif`;
          ctx.fillStyle = '#6b7280';
          ctx.textAlign = 'center';
          ctx.fillText(`${sideAngle.toFixed(0)}°`, centerX - monitorWidth / 2 - 15, centerY - distancePixels + 10);
          ctx.fillText(`${sideAngle.toFixed(0)}°`, centerX + monitorWidth / 2 + 15, centerY - distancePixels + 10);
        }

        // Measurement labels
        ctx.font = `${fontSize * 0.8}px sans-serif`;
        ctx.fillStyle = '#374151';
        ctx.textAlign = 'center';

        if (setup === 'single') {
          // Single monitor width measurement - positioned above the measurement line
          const measurementY = monitorY - 10;
          ctx.fillText(`${screenWidth.toFixed(0)}cm`, centerX, measurementY);

        } else if (setup === 'triple') {
          const sideAngleRad = ((180 - angle) / 2) * Math.PI / 180;

          // Center monitor width measurement - positioned above the measurement line
          const measurementY = monitorY - 10;
          ctx.fillText(`${screenWidth.toFixed(0)}cm`, centerX, measurementY);

          // Left monitor width measurement
          const leftMonitorX = centerX - monitorWidth / 2;

          ctx.save();
          ctx.translate(leftMonitorX, monitorY);
          ctx.rotate(-sideAngleRad);
          ctx.fillText(`${screenWidth.toFixed(0)}cm`, -monitorWidth / 2, -10);
          ctx.restore();

          // Right monitor width measurement
          const rightMonitorX = centerX + monitorWidth / 2;

          ctx.save();
          ctx.translate(rightMonitorX, monitorY);
          ctx.rotate(sideAngleRad);
          ctx.fillText(`${screenWidth.toFixed(0)}cm`, monitorWidth / 2, -10);
          ctx.restore();
        }
      }

      drawMonitorTopView(ctx, x, y, width, height, type = 'flat', curveRadius = null, screenPixels = 0) {
        if (type === 'curved' && curveRadius) {
          this.drawCurvedMonitorTopView(ctx, x, y, width, height, curveRadius, screenPixels);
        } else {
          this.drawFlatMonitorTopView(ctx, x, y, width, height);
        }
      }

      drawFlatMonitorTopView(ctx, x, y, width, height) {
        ctx.fillRect(x, y, width, height);
        ctx.strokeRect(x, y, width, height);

        ctx.fillStyle = '#1e3a8a';
        ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
        ctx.fillStyle = '#1e40af';
      }

      drawCurvedMonitorLine(ctx, centerX, centerY, width, curveRadius, screenPixels) {
        const curvature = Math.max(10, screenPixels * 200 / curveRadius);

        ctx.beginPath();
        ctx.moveTo(centerX - width / 2, centerY);
        ctx.quadraticCurveTo(centerX, centerY - curvature, centerX + width / 2, centerY);
        ctx.stroke();
      }

      drawCurvedMonitorTopView(ctx, x, y, width, height, curveRadius, screenPixels) {
        const curvature = Math.max(height * 0.3, screenPixels * 200 / curveRadius);

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.quadraticCurveTo(x + width / 2, y - curvature, x + width, y);
        ctx.lineTo(x + width, y + height);
        ctx.quadraticCurveTo(x + width / 2, y + height - curvature, x, y + height);
        ctx.closePath();

        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#1e3a8a';
        ctx.beginPath();
        ctx.moveTo(x + 1, y + 1);
        ctx.quadraticCurveTo(x + width / 2, y - curvature + 1, x + width - 1, y + 1);
        ctx.lineTo(x + width - 1, y + height - 1);
        ctx.quadraticCurveTo(x + width / 2, y + height - curvature + 1, x + 1, y + height - 1);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#1e40af';
      }
    }

    // Initialize calculator when DOM is loaded
    window.addEventListener('DOMContentLoaded', () => {
      new FOVCalculator();
    });
  </script>
{% endblock inline_javascript %}
